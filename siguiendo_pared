
//Motor derecho
int PinIN1_de = 12;
int PinIN2_de = 11;
int EN_de = 6;

//Motor izquierdo
int PinIN1_iz = 10;
int PinIN2_iz = 9;
int EN_iz = 5;

//Sensor fronal
int front_trg = 8;
int front_ec = A5;

//Sensor izquierdo
int left_trg = 7;
int left_ec = A4;

//Sensor derecho
int right_trg = 4;
int right_ec = A3;

//Lector frontal
int front_lector = A2;

//Lector izquierdo
int left_lector = A1;

//Lector derecho
int right_lector = A0;

float front_m = 0;
float left_m = 0;
float right_m = 0;

void setup() {


// Inicializacion de monitor serial
  Serial.begin(9600);

  pinMode(PinIN1_de, OUTPUT);
  pinMode(PinIN2_de, OUTPUT);
  pinMode(EN_de, OUTPUT);

  pinMode(PinIN1_iz, OUTPUT);
  pinMode(PinIN2_iz, OUTPUT);
  pinMode(EN_iz, OUTPUT);

  pinMode(front_trg, OUTPUT);
  pinMode(front_ec, INPUT);

  pinMode(left_trg, OUTPUT);
  pinMode(left_ec, INPUT);

  pinMode(right_trg, OUTPUT);
  pinMode(right_ec, INPUT);

  pinMode(front_lector, INPUT);
  pinMode(left_lector, INPUT);
  pinMode(right_lector, INPUT);

  digitalWrite(front_trg,LOW);
  digitalWrite(left_trg,LOW);
  digitalWrite(right_trg,LOW);

  digitalWrite(EN_de,75);
  digitalWrite(EN_iz,75);
  Serial.print("s_l\t s_f\t s_r\t\t");
  Serial.println();
}

//Funcion de medicion de sensores ultrasonido
// Parametros ---> (puerto echo, puerto triger)
float measure(int ec,int trg){
  long t; //tiempo
  long d; //centimetros
  digitalWrite(trg, HIGH);
  delayMicroseconds(10);
  digitalWrite(trg, LOW);

  t = pulseIn(ec, HIGH); 
  d = t/59;

  Serial.print(d);
  Serial.print("cm\t");
  delay(50);
  return d; 
}

//Giro Derecha
void Right()
{
  digitalWrite (PinIN1_de, HIGH);
  digitalWrite (PinIN2_de, LOW);
  digitalWrite (PinIN1_iz, HIGH);
  digitalWrite (PinIN2_iz, LOW);
  digitalWrite(EN_de,50);
  digitalWrite(EN_iz,50);
}

//Giro izquierda
void Left()
{
  digitalWrite (PinIN1_de, LOW);
  digitalWrite (PinIN2_de, HIGH);
  digitalWrite (PinIN1_iz, LOW);
  digitalWrite (PinIN2_iz, HIGH);
  digitalWrite(EN_de,50);
  digitalWrite(EN_iz,50);
}

//Derecho
void Front()
{
  digitalWrite (PinIN1_de, HIGH);
  digitalWrite (PinIN2_de, LOW);
  digitalWrite (PinIN1_iz, LOW);
  digitalWrite (PinIN2_iz, HIGH);
  digitalWrite(EN_de,40);
  digitalWrite(EN_iz,40);
}

//Derecho con desface hacia derecha
void Right_front()
{
  digitalWrite (PinIN1_de, HIGH);
  digitalWrite (PinIN2_de, LOW);
  digitalWrite (PinIN1_iz, LOW);
  digitalWrite (PinIN2_iz, HIGH);
  digitalWrite(EN_de,10);
  digitalWrite(EN_iz,200);
}

//Derecho con desface a izquierda
void Left_front()
{
  digitalWrite (PinIN1_de, HIGH);
  digitalWrite (PinIN2_de, LOW);
  digitalWrite (PinIN1_iz, LOW);
  digitalWrite (PinIN2_iz, HIGH);
  digitalWrite(EN_de,200);
  digitalWrite(EN_iz,10);
}

//Detener motor
void Stop()
{
  digitalWrite (PinIN1_de, LOW);
  digitalWrite (PinIN2_de, LOW);
  digitalWrite (PinIN1_iz, LOW);
  digitalWrite (PinIN2_iz, LOW);
}
  
//Programa siguiendo pared derecha
void solver_d(){
  float df = measure(front_ec, front_trg);
  float dd = measure(right_ec, right_trg);
  float di = measure(left_ec, left_trg);
  Front(); // editar para que se haga 2 segundos
  if (df > 30 && dd<= 30 ){
    Front ();
  }
  else if (df < 30 && dd<= 30 ){
    Left();
    while (df>30){
      Front(); //como le ponemos para que solo avance un espacio
    }
  }
  else if (dd> 30 ){
    Right();
    while (df>30){
      Front(); //como le ponemos para que solo avance un espacio
  }
}
}
// solucion usando pared izquierda
void solver_i(){
  float df = measure(front_ec, front_trg);
  float dd = measure(right_ec, right_trg);
  float di = measure(left_ec, left_trg);
  Front(); // editar para que se haga 2 segundos
  if (df > 30 && di<= 30 ){
    Front ();
  }
  else if (df < 30 && di<= 30 ){
    Right();
    while (df>30){
      Front(); //como le ponemos para que solo avance un espacio
    }
  }
  else if (di> 30 ){
    Left();
    while (df>30){
      Front(); //como le ponemos para que solo avance un espacio
  }
}
}
//Funcion de calibrar
void calibrar()
{
  float dd = measure(right_ec, right_trg);
  float di = measure(left_ec, left_trg);
  float dif = abs(dd-di);
  if (dif>5)
  {
    while (dd> di){
      Right_front();
    } 
  } 
  else if (dd> di)
  {
    while(dd< di){
      Left_front();
    }
  }
}
//programa inicial
void loop(){
  solver_i();
  // solo se me ocurre poner un sensor de posicion para que sepa que ya esta en la piramide 
//  if (si esta inclinado){
//    float df = measure(front_ec, front_trg);
//    float dd = measure(right_ec, right_trg);
//    float di = measure(left_ec, left_trg);
//    if (df<30 && di<30 && dd< 30){
//      loop();{
//      solver_d()
//    }
//  }
}  
//segun yo tiene sentido jiji ahi me dicen qpd pero el valor de 30 hay que checar que valor serÃ­a para que jale y si si da las vueltas bien 
